{
  "name": "stampit",
  "version": "1.1.0",
  "description": "Create objects from reusable, composable behaviors.",
  "author": {
    "name": "Eric Elliott",
    "url": "http://ericleads.com"
  },
  "main": "./stampit.js",
  "keywords": [
    "objects",
    "prototypal",
    "object oriented",
    "browser",
    "inheritance",
    "oo",
    "node"
  ],
  "repository": {
    "type": "git",
    "url": "git@github.com:ericelliott/stampit.git"
  },
  "dependencies": {
    "mout": "~0.5.0"
  },
  "devDependencies": {
    "grunt": "~0.4.1",
    "grunt-saucelabs": "~4.0.4",
    "grunt-browserify": "~1.2.1",
    "grunt-contrib-jshint": "~0.6.2",
    "grunt-contrib-connect": "~0.3.0",
    "grunt-contrib-uglify": "~0.2.5"
  },
  "scripts": {
    "test": "scripts/test.sh"
  },
  "license": "MIT",
  "readme": "# Stampit\n\nCreate objects from reusable, composable behaviors.\n\n## Status\n\nStampit was written as an example for the book, [\"Programming JavaScript Applications\" (O'Reilly)](http://ericleads.com/javascript-applications/), but it has been in production use for more than a year. The API has been quite stable. There will be no breaking changes going forward.\n\n[Known Issues](https://github.com/dilvie/stampit/issues?state=open)\n\n\n## Features\n\n * Create factory functions (called stamps) which stamp out new objects. All of the new objects inherit all of the prescribed behavior.\n\n * Compose stamps together to create new stamps.\n\n * Inherit methods and default state.\n\n * Supports composable private state and privileged methods.\n\n * State is cloned for each instance, so it won't be accidentally shared.\n\n * For the curious - it's great for [learning about prototypal OO](http://ericleads.com/2013/02/fluent-javascript-three-different-kinds-of-prototypal-oo/). It mixes three major types of prototypes:\n   1. differential inheritance, aka delegation (for methods),\n   2. cloning, aka concatenation/exemplar prototypes (for state),\n   3. functional / closure inheritance (for privacy / encapsulation)\n\n## What's the Point?\n\nPrototypal OO is great, and JavaScript's capabilities give us some really powerful tools to explore it, but it could be easier to use.\n\nBasic questions like \"how do I inherit privileged methods and private data?\" and \"what are some good alternatives to inheritance hierarchies?\" are stumpers for many JavaScript users.\n\nLet's answer both of these questions at the same time. First, we'll use a closure to create data privacy:\n\n```js\nvar a = stampit().enclose(function () {\n  var a = 'a';\n  this.getA = function () {\n    return a;\n  };\n});\n```\n\nIt uses function scope to encapsulate private data. Note that the getter must be defined inside the function in order to access the closure variables.\n\nLet's see if that worked:\n\n```js\na(); // Object -- so far so good.\na().getA(); // \"a\"\n```\n\nYes. Got it. In both of these instances, we actually created a brand new object, and then immediately threw it away, because we didn't assign it to anything. Don't worry about that.\n\nHere's another:\n\n```js\nvar b = stampit().enclose(function () {\n  var a = 'b';\n  this.getB = function () {\n    return a;\n  };\n});\n```\n\nThose `a`'s are not a typo. The point is to demonstrate that `a` and `b`'s private variables won't clash.\n\nBut here's the real treat:\n\n```js\nvar c = stampit.compose(a, b);\n\nvar foo = c(); // we won't throw this one away...\n\nfoo.getA(); // \"a\"\nfoo.getB(); // \"b\"\n```\n\nWAT? Yeah. You just inherited privileged methods and private data from two sources at the same time.\n\nBut that's boring. Let's see what else is on tap:\n\n```js\n// Some more privileged methods, with some private data.\n// Use stampit.mixIn() to make this feel declarative:\nvar availability = stampit().enclose(function () {\n  var isOpen = false; // private\n\n  return stampit.mixIn(this, {\n    open: function open() {\n      isOpen = true;\n      return this;\n    },\n    close: function close() {\n      isOpen = false;\n      return this;\n    },\n    isOpen: function isOpenMethod() {\n      return isOpen;\n    }\n  });\n});\n\n// Here's a mixin with public methods, and some state:\nvar membership = stampit({\n    add: function (member) {\n      this.members[member.name] = member;\n      return this;\n    },\n    getMember: function (name) {\n      return this.members[name];\n    }\n  },\n  {\n    members: {}\n  });\n\n// Let's set some defaults:\nvar defaults = stampit().state({\n      name: 'The Saloon',\n      specials: 'Whisky, Gin, Tequila'\n    });\n\n// Classical inheritance has nothing on this. No parent/child coupling. No deep inheritance hierarchies.\n// Just good, clean code reusability.\nvar bar = stampit.compose(defaults, availability, membership);\n\n// Note that you can override state on instantiation:\nvar myBar = bar({name: 'Moe\\'s'});\n\n// Silly, but proves that everything is as it should be.\nmyBar.add({name: 'Homer' }).open().getMember('Homer');\n```\n\n## More chaining\n\nYou can change the stamp in question (`this`) using chaining methods.\n\nChain `.methods()` ...\n\n```js\nvar myStamp = stampit().methods({\n  foo: function () {\n    return 'foo';\n  },\n  methodOverride: function () {\n    return false;\n  }\n}).methods({\n  bar: function () {\n    return 'bar'\n  },\n  methodOverride: function () {\n    return true;\n  }\n});\n```\n\nAnd `.state()` ...\n\n```js\nmyStamp.state({\n  foo: {bar: 'bar'},\n  stateOverride: false\n}).state({\n  bar: 'bar',\n  stateOverride: true\n});\n```\n\nAnd `.enclose()` ...\n\n```js\nmyStamp.enclose(function () {\n  var secret = 'foo';\n\n  this.getSecret = function () {\n    return secret;\n  };\n}).enclose(function () {\n  this.a = true;\n}).enclose({\n  bar: function bar() {\n    this.b = true;\n  }\n}, {\n  baz: function baz() {\n    this.c = true;\n  }\n});\n\nvar obj = myStamp.create();\nobj.getSecret && obj.a && obj.b && obj.c; // true\n```\n\nAnd `.compose()`. But unlike the other chaining methods this one creates a new stamp object.\n\n```js\nvar newStamp = baseStamp.compose(myStamp);\n```\n\n## Pass multiple objects into .methods(), .state(), .enclose(), or .compose().\n\nStampit mimics the behavior of `_.extend()`, `$.extend()` when you pass multiple objects into one of the prototype methods. In other words, it will copy all of the properties from those objects to the `.methods`, `.state`, or `.enclose` prototype for the stamp. The properties from later arguments in the list will override the same named properties of previously passed in objects.\n\n```js\n  var obj = stampit().methods({\n    a: function () { return 'a'; }\n  }, {\n    b: function () { return 'b'; }\n  }).create();\n```\n\nOr `.state()` ...\n\n```js\n  var obj = stampit().state({\n    a: 'a'\n  }, {\n    b: 'b'\n  }).create();\n```\n\nOr even `.compose()` ...\n\n```js\n  var obj = abstractStamp.compose(concreteStamp, additionalStamp, utilityStamp).create();\n```\n\n# Stampit API #\n\n**Source: stampit.js**\n\n### stampit() ###\n\nReturn a factory function (called a stamp) that will produce new objects using the\nprototypes that are passed in or composed.\n\n* `@param {Object} [methods]` A map of method names and bodies for delegation.\n* `@param {Object} [state]` A map of property names and values to clone for each new object.\n* `@param {Function} [enclose]` A closure (function) used to create private data and privileged methods.\n* `@return {Function} stamp` A factory to produce objects using the given prototypes.\n* `@return {Function} stamp.create` Chaining sugar that invokes the stamp.\n* `@return {Object} stamp.fixed` An object map containing the fixed prototypes.\n* `@return {Function} stamp.methods` Add methods to the methods prototype. Chainable.\n* `@return {Function} stamp.state` Add properties to the state prototype. Chainable.\n* `@return {Function} stamp.enclose` Add or replace the closure prototype. Chainable.\n* `@return {Function} stamp.compose` Add stamp to stamp. Chainable.\n\n\n## The stamp object ##\n\n### stamp.methods() ###\n\nTake n objects and add them to the methods prototype. Changes `this` object.\n* @return {Object} stamp  The stamp in question (`this`).\n\n\n### stamp.state() ###\n\nTake n objects and add them to the state prototype. Changes `this` object.\n* @return {Object} stamp  The stamp in question (`this`).\n\n\n### stamp.enclose([arg1] [,arg2] [,arg3...]) ###\n\nTake n functions, an array of functions, or n objects and add\nthe functions to the enclose prototype. Changes `this` object.\n* @return {Object} stamp  The stamp in question (`this`).\n\nFunctions passed into `.enclose()` are called any time an\nobject is instantiated. That happens when the stamp function\nis invoked, or when the `.create()` method is called.\n\n\n### stamp.compose([arg1] [,arg2] [,arg3...]) ###\n\nTake one or more factories produced from stampit() and\ncombine them with `this` to produce and return a new factory object.\nCombining overrides properties with last-in priority.\n * @return {Function} A new stampit factory composed from arguments.\n\n\n### stamp.create([properties] [,arg2] [,arg3...]) ###\n\nJust like calling `stamp()`, `stamp.create()` invokes the stamp\nand returns a new instance. The first argument is an object\ncontaining properties you wish to set on the new objects.\n\nThe remaining arguments are passed to all `.enclose()`\nfunctions. **WARNING** Avoid using two different `.enclose()`\nfunctions that expect different arguments. `.enclose()`\nfunctions that take arguments should not be considered safe to\ncompose with other `.enclose()` functions that also take\narguments. Taking arguments with an `.enclose()` function is an\nanti-pattern that should be avoided, when possible.\n\n\n## Utility methods ##\n\n### stampit.compose() ###\n\nTake two or more stamps produced from stampit() and\ncombine them to produce a new stamp. Combining overrides\nproperties with last-in priority.\n\n* `@param {...Function} stamp` any number of stamps.\n* `@return {Function}` A new stamp composed from arguments.\n\n\n### stampit.mixIn(destObj, source1 [, sourc2] [, source3]...) ###\n\nTake a destination object followed by one or more source objects,\nand copy the source object properties to the destination object,\nwith last in priority overrides.\n\n* `@param {Object} destination` An object to copy properties to.\n* `@param {...Object} source` An object to copy properties from.\n* `@returns {Object}`\n\n\n### stampit.extend() ###\n\nAlias for `mixIn`.\n\n\n### stampit.isStamp(obj) ###\n\nTake an object and return true if it's a stamp, false otherwise.\n\n* `@param {Object} destination` An object to copy properties to.\n* `@returns {Boolean}`\n\n\n### stampit.convertConstructor() ###\n\nTake an old-fashioned JS constructor and return a stamp  that\nyou can freely compose with other stamps. It is possible to\nuse constructors that take arguments. Simply pass the arguments\ninto the returned stamp after the properties object:\n`var myInstance = myStamp(props, arg1, arg2);`\n\nNote that if you use this feature, it is **not safe** to compose\nthe resulting stamp with other stamps willy-nilly, because if two\ndifferent stamps depend on the argument passing feature, the arguments\nwill probably clash with each other, producing very unexpected results.\n\n * @param  {Function} Constructor \n * @return {Function} A composable stampit factory (aka stamp).\n\n```js\n  // The old constructor / class thing...\n  var Constructor = function Constructor() {\n    this.thing = 'initialized';\n  };\n  Constructor.prototype.foo = function foo() { return 'foo'; };\n\n  // The conversion\n  var oldskool = stampit.convertConstructor(Constructor);\n\n  // A new stamp to compose with...\n  var newskool = stampit().methods({\n      bar: function bar() { return 'bar'; }\n     // your methods here...\n    }).enclose(function () {\n      this.baz = 'baz';\n    });\n\n  // Now you can compose those old constructors just like you could\n  // with any other stamp...\n  var myThing = stampit.compose(oldskool, newskool);\n\n  var t = myThing();\n\n  t.thing; // 'initialized',\n\n  t.foo(); // 'foo',\n\n  t.bar(); // 'bar'\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/ericelliott/stampit/issues"
  },
  "homepage": "https://github.com/ericelliott/stampit",
  "_id": "stampit@1.1.0",
  "_from": "stampit@"
}
